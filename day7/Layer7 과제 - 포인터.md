# Layer7 과제 - 포인터



## 포인터의 개념

컴퓨터에서 메인 메모리는 **바이트** 단위로 나누어진다. 각각의 바이트는 정보를 담고있으며, 각 바이트는 고유한 **주소**를 가지고있다.

우리가 작성한 프로그램은 실행할 코드와 데이터를 둘다 담고있다. 프로그램에 있는 각 변수는 그 크기만큼 메모리를 차지한다.

아래의 프로그램을 보자.

```C
#include <stdio.h>

int main(void)
{
    int a = 0x1234;
    int b = 0x5678;

    printf("a's address: %#lx\na's value: %d\n", &a, a); 
  //&는 변수 앞에 붙을시 변수의 주소를 가져오는 연산자다.
    printf("b's address: %#lx\nb's value: %d\n", &b, b);

    return 0;
}
```

 위 프로그램을 실행시키면..

```bash
parallels@ubuntu:~/test$ ./a.out
a's address: 0x7ffec6d5d448
a's value: 4660
b's address: 0x7ffec6d5d444
b's value: 22136
```

보면 a와  b는 각각 특정한 '주소'를 가지고있다. 그리고 순차적으로 그 주소가 데이터형만큼 정렬되어있다.(스택은 위에서 아래로.)

C에서 포인터는 이 주소의 값을 담는 특별한 변수다. 그리고 담고있는 주소가 a의 주소라면, a를 가리키고있는 포인터 변수라고 표현하면 된다.

## 포인터의 선언법

포인터는 아래와 같은 형식으로 선언한다.

```c
datatype *varname;
```

 변수명 앞에 별표가 붙든, 데이터타입 뒤에 별표가 붙든 상관없다.

예를들어 아래의 코드는

```c
int* p;
```

int형 변수의 주소를 담는(가리키는) 포인터 변수 p를 선언했다.

## 포인터의 초기화

포인터는 설명했듯이, '주소'를 담는 변수다. 그러므로 변수의 초기값도 어떠한 변수나 특정한 메모리 주소를 가리켜야한다.

```c
int a;
int* p;
p = &a;
```

여기서 &는 변수의 주소를 가져오는 변수라고 했다. 즉, 주소를 담는 포인터 변수 p에 a의 주소를 넘겨준것이다. 이러면 p는 a를 가리키는 상태가 된다. 그리고 위 코드는,

```c
int a;
int* p = &a;
```

위와 같이 선언과 동시에 초기화를 시켜줄수도있다.

그리고 포인터는 특별하게 아래와 같은 방법으로도 사용할수있다.

```c
char* data = "kafuuchin0";
```

저 쌍따옴표는 string literal이라는 문법인데, 특정 메모리주소(코드 섹션)에다가 문자열 kafuuchin0+NULL을 넣고, 그 주소를 반환한다. 그리고 그 주소를 data가 가리키게 되는것이다. 이러면 상수형 문자열을 선언할수있다. 배열형식의 문자열과의 차이점은 이 문자열은 변경이 불가능하다. 왜냐하면 저 문자열은 코드섹션에 위치하게되는데, 코드섹션은 쓰기권한이 없기때문에 만약에 저 문자열을 변경하려고하면, 런타임 에러가 발생하게된다. 반대로 배열은 그 데이터를 스택에 복사하고 사용하기때문에 변경시에도 문제가 없다.

## 왜 포인터를 쓰는가?

1. 복잡한 자료구조의 표현
   - **링크드 리스트**
2. 배열의 특정 요소에 접근하기 위해서 -> 배열을 더 쉽게 관리할수있음. -> 문자열을 더 쉽게 다룰수있음.
3. 메모리에 있는 데이터를 직접적으로 제어할수있음.
4. 동적 메모리.
5. 함수에서 인자로 받은 변수의 값을 바꾸고싶을때.
6. 메모리를 효율적으로 사용할수있음. (포인터의 크기는 항상 64bit에서는 8, 32bit에서는 4바이트임.)
7. 빠른속도로 데이터를 주고받을수있음(데이터를 하나하나 복사하는것보다는 주소를 주고받는게 더 편하다.)

## 포인터의 예시.

1. 역참조 연산자(*).

```c
int a;
int* p=&a;

printf("%d\n",*p)
```

위 예시는 역참조 연산자의 가장 간단한 예다. 역참조 연산자는 p가 가지고있는 변수의 주소에 접근한다. 그래서 그 주소에 있는 값을 수정하거나, 읽어올수있다.

2. Call-by-reference& 포인터 변수를 리턴하는 함수

Call-by-reference는 함수를 호출할때 매개변수로 변수의 값이 아닌 변수의 주소를 받는것이 핵심이다.

```c
#include <stdio.h>

int* max(int* a, int* b)
{
  return (*a > *b) ? a : b;
}

int main(void)
{
  int a = 3, b = 5;
  int* p = max(&a,&b);
  
  printf("%d\n", *p);
  
  return 0;
}
```

아래 코드를 실행하면,

```bash
parallels@ubuntu:~/test$ ./a.out
5
```

위와 같은 결과가 나오는데, max함수는 매개변수로 두 변수의 주소를 받고, 역참조 연산자를 이용해서 두개의 값에 접근에 대소비교를 한후, 가장 큰 값을 가진 변수의 '주소'를 리턴한다. 즉, 함수의 리턴형의 포인터라는것은, 주소를 반환한다는것과 같은 의미다.

3. 배열의 특정 요소에 접근하기.

배열과 포인터는 밀접한 관계가 있다. 배열도 실제로는 데이터를 가리키고있다. 하지만 가리키는곳을 바꿀수 없다.

포인터로 배열의 원소에 접근해서 원하는 작업을 수행할수있다. 아래의 코드는 배열도 어떠한 값을 가리키는 상수형 포인터라는 것을 증명하고, 포인터를 이용해서 배열에 접근하는것에 대한 예제이다.

```c
#include <stdio.h>

int main(void)
{
    int a[5] = {1,2,3,4,5};

    int* p = &a[0];

    for(int i = 0; i < 5; i++)
        printf("%d\n", *(p+i));
	
  	printf("================\n");
  
    for(int i = 0; i < 5; i++)
        printf("%d\n", *(a+i));

    return 0;
}
```

위 코드를 실행해보면

```c
parallels@ubuntu:~/test$ ./a.out
1
2
3
4
5
================
1
2
3
4
5
```

아래와 같은 결과가 나오게 된다. 그리고 이 예제에서 알수있는것은, []연산자는 *(a+i)를 간소화 시킨것이다.  그러므로 아래의 코드로 작성해도 같은 결과를 얻을수있다.

```c
#include <stdio.h>

int main(void)
{
    int a[5] = {1,2,3,4,5};

    int* p = &a[0];

    for(int i = 0; i < 5; i++)
        printf("%d\n", p[i]);

    printf("================\n");

    for(int i = 0; i < 5; i++)
        printf("%d\n", a[i]);

    return 0;
}
```

