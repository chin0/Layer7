# 3일차 과제 - 배열(1,2차원) 보고서



### 배열이란?

- 특정 수의 크키만큼 같은 자료형의 데이터를 저장할수있는 자료구조.

![array_declaration](/Users/kafuuchin0/Downloads/array_declaration.jpg)

- 배열은 위 그림과 같이 이루어져있다. 배열에 저장되어있는 각 요소와 그 요소의 번호인 인덱스가 있고, 그 인덱스로 위치를 계산해 데이터를 저장하거나, 데이터를 가져온다.
- 배열은 Type Name [size]와 같은 형식으로 선언한다. 위와 같이 C의 Compound literals문법으로 선언과 동시에 초기화를 할수있다.
- 배열은 다른 자료구조에 비해 빠른 속도로 데이터에 접근할수 있다는 장점이 있지만, 배열 중간에 데이터를 삽입하거나 삭제하기 불편하다는 단점이 있다.
  - 배열은 데이터를 삽입할때 해당 인덱스와 배열 끝에 있는 값까지 전부 한칸씩 오른쪽으로 밀어준후 데이터를 넣어야한다. 삭제도 마찬가지로 해당 인덱스와 배열 끝에 있는 값까지 전부 한칸씩 왼쪽으로 밀어줘야한다.

### 1차원 배열의 활용(C)

- 배열의 주 용도는 같은 성질을 가진 데이터를 한꺼번에 관리할때 사용한다.
  - 예를들어, 30명의 수학성적을 관리한다고 하면, 30개의 정수를 담는 배열을 선언해서 그 배열에 30명의 수학성적을 넣어 관리할수 있다.
- 배열은 아래와 같은 방법으로 초기화할수있다.
  - 모든 배열의 요소가 동일한 값으로 초기화되어야 할때:
    - int array[10] = {0,} (모든 배열 요소의 값을 0으로)
    - for문돌리기
  - 특정 인덱스만 초기화하고 싶을때
    - int array[10] = {[1] = 10, [5] =20}
  - 각각 초기화하고싶을때
    - int array[10] = {1,5,2,3,5,9,3,2,1,2}
- 배열의 값 접근& 수정
  - array[index]와 같은 형식으로 접근&수정할수있다.
    - array[2] = 2;
    - int b = array[3];


- 배열의 삽입&삭제
  - 배열의 삽입의 경우에는 삽입할 인덱스 ~ 데이터가 있는 마지막 인덱스까지 오른쪽으로 한칸 밀어준후 해당 인덱스에 값을 넣는다.
  - 배열의 삭제의 경우에는 삭제할인덱스 + 1 ~ 데이터가 있는 마지막 인덱스까지 왼쪽으로 한칸 밀어준다.
  - memmove로 더 빠르게 처리할수있다.



### 2차원 배열

- 일차원 배열을 요소로 갖는 배열이다.
- int array\[Row_size\]\[Column_size\] 같은 형식으로 선언한다.



### 이차원 배열의 활용

- 이차원 배열은 1차원 배열을 요소갖는 배열이라는 점에서 여러가지 문제에서 활용할수있다.
  - 여러개의 문자열을 저장할때.
  - **행렬을 표현할때**
- 초기화 방식
  - int a\[8\]\[8\] = {1,2,3,4,5,6,7,8}같이 일차원 배열처럼 초기화할수있다. 남는부분은 0으로 채워진다.
    - a\[0\]\[0\]부터 a[0]부분이 꽉 차면 a\[1\][0]… 이런식으로 초기화된다.
  - int a\[8\]\[8\] = {{1,2,3},{4,5,6}}처럼 일차원 배열을 포개어놓는형식으로 초기화할수있다.
    - a[0]은 {1,2,3}이 들어가고 a[1]은 {4,5,6}이 들어가게된다.
  - int a\[8]\[8] = {[1] = {1,2,3}, [5] = {[7] = 123}}처럼 특정 인덱스만 초기화를 할수있고, 각각의 일차원 배열도 똑같이 특정 인덱스만 초기화할수있다.

### 이차원 배열을 저장하는 방식.

예제코드

```c
#include <stdio.h>

int main(void)
{
    int a[3][3] = {{1,2,3},{4,5,6},{7,8,9}};

    printf("a[0] = {%d,%d,%d}\n",a[0][0],a[0][1],a[0][2]);
    printf("a[0]'s address: %#lx\n",a[0]);
    printf("a[1]'s address: %#lx\n",a[1]);
    printf("a[2]'s address: %#lx\n",a[2]);

}
```

위 코드를 실행하면

```bash
parallels@ubuntu:~/test/array$ ./a.out
a[0] = {1,2,3}
a[0]'s address: 0x7ffd0fabb930
a[1]'s address: 0x7ffd0fabb93c
a[2]'s address: 0x7ffd0fabb948
```

결과가 나온다.

더 자세하게 알아보기 위해서 어셈분석을 해보자.

```assembly
   0x0000000000400590 <+0>:	push   rbp
   0x0000000000400591 <+1>:	mov    rbp,rsp
   0x0000000000400594 <+4>:	sub    rsp,0x50
   0x0000000000400598 <+8>:	movabs rdi,0x4006f4
   0x00000000004005a2 <+18>:	movabs rax,0x4006d0
   0x00000000004005ac <+28>:	mov    ecx,0x24
   0x00000000004005b1 <+33>:	mov    edx,ecx
   0x00000000004005b3 <+35>:	lea    rsi,[rbp-0x30]
   0x00000000004005b7 <+39>:	mov    QWORD PTR [rbp-0x38],rdi
   0x00000000004005bb <+43>:	mov    rdi,rsi
   0x00000000004005be <+46>:	mov    rsi,rax
   0x00000000004005c1 <+49>:	call   0x400470 <memcpy@plt>
```

위 코드를 보면 일단 위 코드같이 약간 복사할 데이터가 많으면 memcpy를 내부적으로 호출하는것을 알수있다. 0x4006d0은 위 코드의 {1,2,3,4,5,6,7,8,9}가 들어있는 부분이다. 이 크기는 0x24(36)만큼이고 우리가 선언한 이차원 배열은 rbp-0x30에 있는것을 알수있다. 그래서 위 코드를 보면 결국 내부적으로는

```c
int temp[9] = {1,2,3,4,5,6,7,8,9};

int main(void)
{
	int array[3][3];
	memcpy(array[0],temp,9 * sizeof(int));
}
```

와 같다는것을 확인할수있다.

그리고 array[0]의 값을 출력하는 부분을 보면

```c
   0x00000000004005c6 <+54>:	mov    esi,DWORD PTR [rbp-0x30]
   0x00000000004005c9 <+57>:	mov    edx,DWORD PTR [rbp-0x2c]
   0x00000000004005cc <+60>:	mov    ecx,DWORD PTR [rbp-0x28]
   0x00000000004005cf <+63>:	mov    rdi,QWORD PTR [rbp-0x38]
   0x00000000004005d3 <+67>:	mov    al,0x0
=> 0x00000000004005d5 <+69>:	call   0x400450 <printf@plt>
```

와 같이 rbp - 0x30,0x2c,0x28순서대로 값을 넣는것을 확인할수있는데, 이는 스택의 구조상 값이 낮은주소에서 높은주소로 쌓이기때문이다. (스택은 높은주소에서 낮은주소로 자람.)

어쨌든 rbp - 0x30, rbp - 0x30 + 4, rbp - 0x30 + 8순서로 값을 넣는것을 알수있고, 즉, 이차원 배열의 데이터는 내부적으로 일차원 배열처럼 저장된다는것을 알수있다. 단지 a[0], a[1] ,a[2]는 일차원 배열을 가리키고 있는 포인터라는것이다. 이 포인터들은 각각 0xc(12)바이트 간격으로 떨어져있는것을 확인할수있다. 즉, 아래와 같은 구조가 된다.

```
-------------------------------------
| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
-------------------------------------
  ^		  ^			  ^
  |		  |			  |
 a[0]	 a[1]		 a[2]
```

a\[0\]\[0\]은 a[0]이 가리키고있는곳의 0번요소를 뽑아와라! 라는 의미가 된다. 